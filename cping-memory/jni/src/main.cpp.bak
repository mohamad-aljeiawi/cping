#include "main.h"

#include <thread>
#include <mutex>
#include <chrono>
#include <cmath>
#include <atomic>
#include <unordered_map>
#include <cstring>

SocketClient socketClient;
FrameTimeController fps_controller = FrameTimeController(60);
std::unordered_map<int, std::string> g_class_name_cache;

std::thread network_thread_obj;
Structs::Response shared_response;
Structs::Request shared_request;
std::mutex mutex_req;
std::mutex mutex_res;

uintptr_t lib_base = 0;
pid_t target_pid;
float width = 0.0f;
float height = 0.0f;
float orientation = 0.0f;
bool is_running = true;

void network_thread(SocketClient *client)
{
    while (is_running)
    {
        Structs::Request temp_req{};
        bool received = client->receive_raw(&temp_req, sizeof(temp_req));
        if (!received)
        {
            Logger::e("client->receive_raw failed");
        }
        {
            std::lock_guard<std::mutex> lock(mutex_req);
            shared_request = temp_req;
        }

        Structs::Response temp_res{};
        {
            std::lock_guard<std::mutex> lock(mutex_res);
            temp_res = shared_response;
        }
        bool sent = client->send_raw(&temp_res, sizeof(temp_res));
        if (!sent)
        {
            Logger::e("client->send_raw failed");
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}

int main(int argc, char *argv[])
{
    target_pid = Utils::find_pid_by_package_name("com.tencent.ig");
    if (!target_pid)
    {
        Logger::i("PUBG Mobile is not running!\n");
        return -1;
    }

    lib_base = Utils::find_ue4_base(target_pid);
    if (!lib_base)
    {
        Logger::i("Failed to find libUE4.so base address!\n");
        return -1;
    }

    if (!socketClient.connect_to_server("cping_abstract_socket"))
    {
        Logger::i("Failed to start socket server\n");
        return -1;
    }

    int count_try_get_g_objects = 0;
    uintptr_t g_world = 0;
    uintptr_t g_names = 0;
    while (count_try_get_g_objects < 10)
    {
        g_world = Memory::Read<uintptr_t>(lib_base + Offset::g_world, target_pid);
        g_names = Memory::Read<uintptr_t>(Memory::Read<uintptr_t>(lib_base + Offset::g_name, target_pid) + 0x110, target_pid);

        if (g_world && g_names)
            break;

        count_try_get_g_objects++;
        std::this_thread::sleep_for(std::chrono::milliseconds(2000));
    }

    if (!g_world || !g_names)
    {
        Logger::i("Failed to find g_world or g_names\n");
        return -1;
    }

    auto display = android::ANativeWindowCreator::GetDisplayInfo();
    auto window = android::ANativeWindowCreator::Create("CPING", display.width, display.height);
    Renderer::Init(window, display.width, display.height);

    is_running = true;
    network_thread_obj = std::thread(network_thread, &socketClient);
    while (is_running)
    {

        Renderer::StartFrame();

        ImDrawList *draw_list = ImGui::GetBackgroundDrawList();
        draw_list->AddLine(
            ImVec2(0, 100),             
            ImVec2(ImGui::GetIO().DisplaySize.x, 100),
            IM_COL32(0, 0, 255, 255),
            5.0f
        );

        // fps_controller.start_frame();
        auto frame_start = std::chrono::high_resolution_clock::now();

        Structs::Request request_copy;
        {
            std::lock_guard<std::mutex> lock(mutex_req);
            request_copy = shared_request;
        }
        Structs::Response response_copy;
        response_copy.Count = 0;

        if (width == 0.0f || height == 0.0f)
        {
            printf("width: %f, height: %f, orientation: %f\n", width, height, orientation);
            width = request_copy.ScreenWidth;
            height = request_copy.ScreenHeight;
            orientation = request_copy.ScreenOrientation;

            if (width < height)
            {
                std::swap(width, height);
            }
        }

        uintptr_t u_world = Memory::Read<uintptr_t>(Memory::Read<uintptr_t>(g_world + 0x58, target_pid) + 0x78, target_pid);
        if (!u_world)
            continue;

        uintptr_t u_level = Memory::Read<uintptr_t>(u_world + Offset::persistent_level, target_pid);
        if (!u_level)
            continue;

        uintptr_t actors_list = Ue4::get_actors_array(u_level, Offset::u_level_to_a_actors, 0x448, target_pid);
        if (!actors_list)
            continue;

        uintptr_t u_level_to_a_actors = Memory::Read<uintptr_t>(actors_list, target_pid);
        if (!u_level_to_a_actors)
            continue;

        int u_level_to_a_actors_count = Memory::Read<int>(actors_list + sizeof(uintptr_t), target_pid);
        if (u_level_to_a_actors_count <= 0 || u_level_to_a_actors_count >= 1000)
            continue;

        uintptr_t player_controller = Memory::Read<uintptr_t>(Memory::Read<uintptr_t>(Memory::Read<uintptr_t>(u_world + 0x38, target_pid) + 0x78, target_pid) + 0x30, target_pid);
        if (!player_controller)
            continue;

        uintptr_t player_camera_manager = Memory::Read<uintptr_t>(player_controller + Offset::player_camera_manager, target_pid);
        if (player_camera_manager <= 0)
            continue;

        Structs::CameraCacheEntry camera_cache = Memory::Read<Structs::CameraCacheEntry>(player_camera_manager + Offset::camera_cache, target_pid);
        Structs::MinimalViewInfo minimal_view_info = camera_cache.POV;
        uintptr_t gname_buff[100] = {0};
        Memory::ReadArray(g_names, gname_buff, target_pid);

        for (int i = 0; i < u_level_to_a_actors_count; i++)
        {
            uintptr_t actor = Memory::Read<uintptr_t>(u_level_to_a_actors + i * sizeof(uintptr_t), target_pid);
            if (!actor)
                continue;

            std::string class_name = Ue4::get_cached_class_name(g_names, actor, gname_buff, &g_class_name_cache, target_pid);
            if (class_name == "none" || class_name.empty())
                continue;

            if (strstr(class_name.c_str(), "VH_PG117_C") || strstr(class_name.c_str(), "BP_CharacterRifle") || strstr(class_name.c_str(), "BP_PlayerRifle") || strstr(class_name.c_str(), "BP_PlayerLobby_Pawn_C") || strstr(class_name.c_str(), "BP_PlayerLobby_Pawn_C") || strstr(class_name.c_str(), "BP_PlayerController"))
                continue;

            uintptr_t actor_root_component = Memory::Read<uintptr_t>(actor + Offset::root_component, target_pid);
            if (!actor_root_component)
                continue;

            Structs::FVector relative_location = Memory::Read<Structs::FVector>(actor_root_component + Offset::relative_location, target_pid);

            if (strstr(class_name.c_str(), "BP_Character") || strstr(class_name.c_str(), "BP_Player"))
            {
                if (response_copy.Count > MAX_OBJECTS)
                    break;

                Structs::FBoxSphereBounds box_sphere_bounds = {};
                Structs::FTransform transform = {};
                if (Ue4::process_object_bounds(
                        actor,
                        {0x498},
                        {0},
                        {0x9D4},
                        {0.45f, 0.45f, 0.65f},
                        0.0f,
                        &box_sphere_bounds,
                        &transform,
                        target_pid))
                {
                    strncpy(response_copy.Objects[response_copy.Count].Name, class_name.c_str(), MAX_NAME_LENGTH - 1);
                    response_copy.Objects[response_copy.Count].Name[MAX_NAME_LENGTH - 1] = '\0';
                    response_copy.Objects[response_copy.Count].Location = relative_location;
                    response_copy.Objects[response_copy.Count].BoxSphereBounds = box_sphere_bounds;
                    response_copy.Objects[response_copy.Count].Transform = transform;
                    response_copy.MinimalViewInfo = minimal_view_info;
                    response_copy.Count++;
                }
            }

            if ((strstr(class_name.c_str(), "VH_") || strstr(class_name.c_str(), "Mirado_") || strstr(class_name.c_str(), "CoupeRB_") || strstr(class_name.c_str(), "Rony_") || strstr(class_name.c_str(), "PickUp_") || strstr(class_name.c_str(), "AquaRail_") || strstr(class_name.c_str(), "BP_Bike_") || strstr(class_name.c_str(), "BP_Bike2_") || strstr(class_name.c_str(), "wing_Vehicle_")))
            {
                if (response_copy.Count > MAX_OBJECTS)
                    break;

                Structs::FBoxSphereBounds box_sphere_bounds = {};
                Structs::FTransform transform = {};

                if (Ue4::process_object_bounds(actor,
                                               {0xb18},
                                               {0x1268},
                                               {0xac},
                                               {0.45f, 0.45f, 0.65f},
                                               0.5f,
                                               &box_sphere_bounds,
                                               &transform,
                                               target_pid))
                {
                    strncpy(response_copy.Objects[response_copy.Count].Name, class_name.c_str(), MAX_NAME_LENGTH - 1);
                    response_copy.Objects[response_copy.Count].Name[MAX_NAME_LENGTH - 1] = '\0';
                    response_copy.Objects[response_copy.Count].Location = relative_location;
                    response_copy.Objects[response_copy.Count].BoxSphereBounds = box_sphere_bounds;
                    response_copy.Objects[response_copy.Count].Transform = transform;
                    response_copy.MinimalViewInfo = minimal_view_info;
                    response_copy.Count++;
                }
            }

            if (strstr(class_name.c_str(), "Pickup_C") || strstr(class_name.c_str(), "PickUp") || strstr(class_name.c_str(), "BP_Ammo") || strstr(class_name.c_str(), "BP_QK") || strstr(class_name.c_str(), "Wrapper"))
            {
                if (response_copy.Count > MAX_OBJECTS)
                    break;

                Structs::FBoxSphereBounds box_sphere_bounds = {};
                Structs::FTransform transform = {};

                if (Ue4::process_object_bounds(actor,
                                               {0x8a0, 0x8a8, 0x8b0, 0x8b8, 0x8c0},
                                               {0x878, 0x878, 0x878, 0x878, 0x878},
                                               {0x170, 0x170, 0x170, 0x170, 0x170},
                                               {1.0f, 1.0f, 1.0f},
                                               0.0f,
                                               &box_sphere_bounds,
                                               &transform,
                                               target_pid))
                {
                    strncpy(response_copy.Objects[response_copy.Count].Name, class_name.c_str(), MAX_NAME_LENGTH - 1);
                    response_copy.Objects[response_copy.Count].Name[MAX_NAME_LENGTH - 1] = '\0';
                    response_copy.Objects[response_copy.Count].Location = relative_location;
                    response_copy.Objects[response_copy.Count].BoxSphereBounds = box_sphere_bounds;
                    response_copy.Objects[response_copy.Count].Transform = transform;
                    response_copy.MinimalViewInfo = minimal_view_info;
                    response_copy.Count++;
                }
            }
        }

        auto frame_end = std::chrono::high_resolution_clock::now();
        float frame_duration_ms = std::chrono::duration<float, std::milli>(frame_end - frame_start).count();
        float fps = 1000.0f / frame_duration_ms;
        printf("[CLIENT] FPS: %.2f, %.2f ms\n", fps, frame_duration_ms);

        {
            std::lock_guard<std::mutex> lock(mutex_res);
            shared_response = response_copy;
        }

        // fps_controller.end_frame();
        Renderer::EndFrame();
    }

    Renderer::Shutdown();
    socketClient.close_connection();
    return 0;
}