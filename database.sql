-- Description: Initial database schema for Cping app
-- Created: 2025-08-16
--======================
--========EXTENSIONS====
--======================
create extension if not exists "uuid-ossp";

create extension if not exists "pgcrypto";

create extension if not exists "pgjwt";

create extension if not exists "pg_net";

create extension if not exists "pg_graphql";

create extension if not exists "pg_stat_statements"
--======================
--========TABLES========
--======================
-- Drop existing tables if they exist (cascade to handle dependencies)
drop table if exists public.persons cascade;

drop table if exists public.person_logs cascade;

drop table if exists public.otps cascade;

drop table if exists public.ipinfos cascade;

drop table if exists public.person_roles cascade;

drop table if exists public.wallets cascade;

drop table if exists public.plans cascade;

drop table if exists public.subscriptions cascade;

drop table if exists public.games cascade;

-- Create persons table
create table public.persons (
  id bigint generated by default as identity not null,
  telegram_id bigint not null,
  first_name text not null,
  last_name text not null default '-'::text,
  username text not null,
  language_code text not null,
  is_premium boolean not null default false,
  created_at timestamp without time zone not null default now(),
  constraint persons_pkey primary key (id),
  constraint persons_telegram_id_key unique (telegram_id),
  constraint persons_username_key unique (username)
) TABLESPACE pg_default;

create unique INDEX persons_telegram_id_key on public.persons using btree (telegram_id) create unique INDEX persons_username_key on public.persons using btree (username)
-- Create person_logs table
create table public.person_logs (
  id bigint generated by default as identity not null,
  person_id bigint not null,
  telegram_id bigint not null,
  first_name text not null,
  last_name text not null default '-'::text,
  username text not null,
  language_code text not null,
  is_premium boolean not null default false,
  created_at timestamp without time zone not null default now(),
  constraint person_logs_pkey primary key (id),
  constraint person_logs_person_id_fkey foreign key (person_id) references persons (id)
) TABLESPACE pg_default;

create unique INDEX person_roles_person_id_key on public.person_roles using btree (person_id)
-- Create otps table
create table public.otps (
  id bigint generated by default as identity not null,
  person_id bigint not null,
  otp text not null,
  expires_at timestamp without time zone not null default (now() + '00:01:00'::interval),
  created_at timestamp without time zone not null default now(),
  constraint otps_pkey primary key (id),
  constraint otps_person_id_fkey foreign KEY (person_id) references persons (id),
  constraint chk_otp_not_empty check ((length(otp) >= 4))
) TABLESPACE pg_default;

-- Create ipinfos table
create table public.ipinfos (
  id bigint generated by default as identity not null,
  person_id bigint null,
  ip text not null,
  city text not null,
  region text not null,
  country text not null,
  loc text not null,
  org text not null,
  timezone text not null,
  device_info text not null,
  device_hash text not null,
  created_at timestamp without time zone not null default now(),
  constraint ipinfos_pkey primary key (id),
  constraint ipinfos_person_id_fkey foreign KEY (person_id) references persons (id)
) TABLESPACE pg_default;

-- Create person_roles table
create table public.person_roles (
  id bigint generated by default as identity not null,
  person_id bigint not null,
  role text not null,
  created_at timestamp without time zone not null default now(),
  constraint person_roles_pkey primary key (id),
  constraint person_roles_person_id_key unique (person_id),
  constraint person_roles_person_id_fkey foreign KEY (person_id) references persons (id),
  constraint chk_valid_role check (
    (
      role = any (
        array['user'::text, 'admin'::text, 'seller'::text]
      )
    )
  )
) TABLESPACE pg_default;

-- Create wallets table
create table public.wallets (
  id bigint generated by default as identity not null,
  person_id bigint not null,
  balance bigint not null default 0,
  created_at timestamp without time zone not null default now(),
  constraint wallets_pkey primary key (id),
  constraint wallets_person_id_fkey foreign KEY (person_id) references persons (id),
  constraint chk_balance_non_negative check ((balance >= 0))
) TABLESPACE pg_default;

-- Create plans table
create table public.plans (
  id bigint generated by default as identity not null,
  name text not null,
  description text not null,
  feature_mask bigint not null default 0,
  price bigint not null default 0,
  created_at timestamp without time zone not null default now(),
  constraint plans_pkey primary key (id),
  constraint chk_price_positive check ((price >= 0)),
  constraint chk_feature_mask_positive check ((feature_mask >= 0))
) TABLESPACE pg_default;

-- Create subscriptions table
create table public.subscriptions (
  id bigint generated by default as identity not null,
  plan_id bigint not null,
  seller_id bigint not null,
  person_id bigint not null,
  status text not null,
  created_at timestamp without time zone not null default now(),
  constraint subscriptions_pkey primary key (id),
  constraint subscriptions_plan_id_fkey foreign KEY (plan_id) references plans (id),
  constraint subscriptions_seller_id_fkey foreign KEY (seller_id) references persons (id),
  constraint subscriptions_person_id_fkey foreign KEY (person_id) references persons (id),
  constraint chk_subscription_status check (
    (
      status = any (
        array['active'::text, 'expired'::text, 'canceled'::text]
      )
    )
  )
) TABLESPACE pg_default;

-- Create games table
create table public.games (
  id bigint generated by default as identity not null,
  name text not null,
  slug text not null,
  description text not null,
  image_url text not null,
  download_url text not null,
  created_at timestamp without time zone not null default now(),
  constraint games_pkey primary key (id)
) TABLESPACE pg_default;

--======================
--========FUNCTIONS=====
--======================
-- Drop existing functions if they exist (cascade to handle dependencies)
drop function if exists is_admin cascade;

drop function if exists fun_generate_unique_otp cascade;

drop function if exists fun_verify_otp cascade;

drop function if exists hmac cascade;

-- ----------------------------------------------------------------------------
-- Function: public.hmac()
-- Purpose:
--   - HMAC function for JWT token generation
--   - Wrapper around extensions.hmac with proper encoding
-- Notes:
--   - Uses UTF-8 encoding for both data and key
--   - Immutable and parallel safe for performance
-- ----------------------------------------------------------------------------
create or replace function public.hmac(data text, key text, type text)
returns bytea
language sql
immutable
parallel safe
as $$
  select extensions.hmac(convert_to(data, 'utf8'), convert_to(key, 'utf8'), type);
$$;

-- ----------------------------------------------------------------------------
-- Function: public.is_admin()
-- Purpose:
--   - Check if the current user is an admin.
--   - Returns true if the current user is an admin, false otherwise.
-- Notes:
--   - SECURITY DEFINER so it can insert into public.profiles regardless of caller role.
--   - search_path pinned to 'public, pg_temp' for safety.
-- ----------------------------------------------------------------------------
create or replace function public.is_admin () returns boolean as $$
declare
  current_telegram_id bigint;
begin
  current_telegram_id := (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint;
  return exists (
    select 1 from persons p
    join person_roles r on r.person_id = p.id
    where p.telegram_id = current_telegram_id and r.role = 'admin'
  );
end;
$$ language plpgsql stable;

-- ----------------------------------------------------------------------------
-- Function: public.fun_generate_unique_otp()
-- Purpose:
--   - Generate a unique OTP for a given person_id.
--   - Ensure OTP is not used in the last 5 minutes.
--   - Limit to 3 OTPs per person in 5 minutes.
--   - Generate a random OTP of specified length (default 6).
--   - Retry if OTP already exists.
-- Notes:
--   - SECURITY DEFINER so it can insert into public.otps regardless of caller role.
--   - search_path pinned to 'public, pg_temp' for safety.
-- ----------------------------------------------------------------------------
create or replace function public.fun_generate_unique_otp (person_id_input bigint, otp_length int default 6) returns text language plpgsql as $$
declare
  var_generated_otp text;
  var_try_count int := 0;
  var_is_otp_exists boolean;
  var_recent_otp_count int := 0;
begin

  select count(*) into var_recent_otp_count
  from otps
  where person_id = person_id_input
    and created_at > now() - interval '5 minutes';

  if var_recent_otp_count >= 3 then
    raise exception 'You must wait before generating another OTP.';
  end if;
  
  loop
    var_generated_otp := (
      select string_agg(
        substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', trunc(random() * 36)::int + 1, 1),
        ''
      )
      from generate_series(1, otp_length)
    );
    
    select exists (
      select 1 from otps
      where otp = var_generated_otp
        and expires_at > now()
    ) into var_is_otp_exists;

    exit when not var_is_otp_exists;

    var_try_count := var_try_count + 1;
    if var_try_count > 10 then
      raise exception 'Failed to generate unique OTP after 10 tries';
    end if;
  end loop;

  insert into otps (person_id, otp)
  values (person_id_input, var_generated_otp);

  return var_generated_otp;
end;
$$;

-- ----------------------------------------------------------------------------
-- Function: public.fun_verify_otp()
-- Purpose:
--   - Verify an OTP and generate a JWT token if valid.
--   - Check OTP validity (exists, not expired, not used in last 5 minutes).
--   - Check device location (new device requires 2 previous locations).
--   - Generate JWT token with user ID, Telegram ID, device hash, role, and expiration.
-- Notes:
--   - SECURITY DEFINER so it can access public.otps and public.ipinfos.
--   - search_path pinned to 'public, extensions, pg_temp' for safety.
--   - Handles NULL values gracefully.
--   - Raises exception if OTP is invalid or device location is not allowed.
--   - Uses new JWT implementation with updated HMAC function
-- ----------------------------------------------------------------------------
create or replace function public.fun_verify_otp (
  otp_input text,
  ip_input text,
  region_input text,
  device_hash_input text
)
returns table (person_id bigint, token text)
language plpgsql
security definer
set search_path = public, extensions, pg_temp
as $$
declare
  var_person_id bigint;
  var_telegram_id bigint;
  var_otp_expires_at timestamp;
  var_is_existing_device boolean;
  var_device_count int;
begin
  select
    p.id,
    p.telegram_id,
    o.expires_at
  into
    var_person_id,
    var_telegram_id,
    var_otp_expires_at
  from otps o
  join persons p on o.person_id = p.id
  where o.otp = otp_input
    and o.expires_at > now()
  order by o.created_at desc
  limit 1;

  if var_person_id is null then
    raise exception 'The verification code is invalid or has expired.';
  end if;

  select count(*) into var_device_count
  from (
    select distinct ip, region, device_hash
    from ipinfos
    where ipinfos.person_id = var_person_id
  ) as location_set;

  select exists (
    select 1
    from ipinfos
    where ipinfos.person_id = var_person_id
      and ip = ip_input
      and region = region_input
      and device_hash = device_hash_input
  ) into var_is_existing_device;

  if var_device_count >= 99 and not var_is_existing_device then
    raise exception 'Login denied: Account already active from 2 different locations.';
  end if;

  return query
  select
    var_person_id as person_id,
    sign(
      json_build_object(
        'sub', var_person_id::text,
        'telegram_id', var_telegram_id::text,
        'device_hash', device_hash_input::text,
        'role', 'authenticated',
        'exp', extract(epoch from now() + interval '14 day')::int
      ),
      'here_is_your_secret_key_jwt',
      'HS256'
    ) as token;
end;
$$;

--======================
--========TRIGGERS======
--======================
--======================
--========INDEXES=======
--======================
--======================
--========POLICIES======
--======================
-- enable RLS all tables
alter table public.games enable row level security;

alter table public.persons enable row level security;

alter table public.person_logs enable row level security;

alter table public.person_roles enable row level security;

alter table public.wallets enable row level security;

alter table public.otps enable row level security;

alter table public.ipinfos enable row level security;

alter table public.plans enable row level security;

alter table public.subscriptions enable row level security;

-- Drop existing policies if they exist (cascade to handle dependencies)
drop policy if exists select_games on public.games cascade;

drop policy if exists select_persons on persons cascade;

drop policy if exists select_person_logs on person_logs cascade;

drop policy if exists select_person_roles on person_roles cascade;

drop policy if exists select_wallets on wallets cascade;

drop policy if exists select_otps on otps cascade;

drop policy if exists select_ipinfos on ipinfos cascade;

drop policy if exists select_plans on plans cascade;

drop policy if exists select_subscriptions on subscriptions cascade;

create policy select_games on public.games for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id::text = current_setting('request.jwt.claims', true)::json ->> 'sub'
    )
  );

create policy select_persons on persons for
select
  using (
    telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    or is_admin ()
  );

create policy update_persons on persons
for update
  using (
    telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    or is_admin ()
  );

create policy select_person_logs on person_logs for
select
  using (
    telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    or is_admin ()
  );

create policy update_person_logs on person_logs
for update
  using (
    telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    or is_admin ()
  );

create policy select_person_roles on person_roles for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = person_roles.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy select_wallets on wallets for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = wallets.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy select_otps on otps for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = otps.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy insert_otps on otps for INSERT
with
  check (
    exists (
      select
        1
      from
        persons p
      where
        p.id = otps.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy select_ipinfos on ipinfos for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = ipinfos.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy insert_ipinfos on ipinfos for INSERT
with
  check (
    exists (
      select
        1
      from
        persons p
      where
        p.id = ipinfos.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy select_plans on plans for
select
  using (true);

create policy select_subscriptions on subscriptions for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = subscriptions.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or exists (
      select
        1
      from
        persons p
      where
        p.id = subscriptions.seller_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );