--=================================================
--========== SCHEMA DATABASE ======================
--=================================================
--==================
--===== TABLES =====
--==================
create table public.persons (
  id bigint generated by default as identity not null,
  telegram_id bigint not null,
  first_name text not null,
  last_name text not null default '-'::text,
  username text not null,
  language_code text not null,
  is_premium boolean not null default false,
  created_at timestamp without time zone not null default now(),
  constraint persons_pkey primary key (id),
  constraint persons_telegram_id_key unique (telegram_id),
  constraint persons_username_key unique (username)
) TABLESPACE pg_default;
CREATE UNIQUE INDEX persons_telegram_id_key ON public.persons USING btree (telegram_id)
CREATE UNIQUE INDEX persons_username_key ON public.persons USING btree (username)

create table public.person_logs (
  id bigint generated by default as identity not null,
  person_id bigint not null,
  telegram_id bigint not null,
  first_name text not null,
  last_name text not null default '-'::text,
  username text not null,
  language_code text not null,
  is_premium boolean not null default false,
  created_at timestamp without time zone not null default now(),
  constraint person_logs_pkey primary key (id),
  constraint person_logs_person_id_fkey foreign key (person_id) references persons (id)
) TABLESPACE pg_default;
CREATE UNIQUE INDEX person_roles_person_id_key ON public.person_roles USING btree (person_id)



create table public.otps (
  id bigint generated by default as identity not null,
  person_id bigint not null,
  otp text not null,
  expires_at timestamp without time zone not null default (now() + '00:01:00'::interval),
  created_at timestamp without time zone not null default now(),
  constraint otps_pkey primary key (id),
  constraint otps_person_id_fkey foreign KEY (person_id) references persons (id),
  constraint chk_otp_not_empty check ((length(otp) >= 4))
) TABLESPACE pg_default;

create table public.ipinfos (
  id bigint generated by default as identity not null,
  person_id bigint null,
  ip text not null,
  city text not null,
  region text not null,
  country text not null,
  loc text not null,
  org text not null,
  timezone text not null,
  device_info text not null,
  device_hash text not null,
  created_at timestamp without time zone not null default now(),
  constraint ipinfos_pkey primary key (id),
  constraint ipinfos_person_id_fkey foreign KEY (person_id) references persons (id)
) TABLESPACE pg_default;

create table public.person_roles (
  id bigint generated by default as identity not null,
  person_id bigint not null,
  role text not null,
  created_at timestamp without time zone not null default now(),
  constraint person_roles_pkey primary key (id),
  constraint person_roles_person_id_key unique (person_id),
  constraint person_roles_person_id_fkey foreign KEY (person_id) references persons (id),
  constraint chk_valid_role check (
    (
      role = any (
        array['user'::text, 'admin'::text, 'seller'::text]
      )
    )
  )
) TABLESPACE pg_default;

create table public.wallets (
  id bigint generated by default as identity not null,
  person_id bigint not null,
  balance bigint not null default 0,
  created_at timestamp without time zone not null default now(),
  constraint wallets_pkey primary key (id),
  constraint wallets_person_id_fkey foreign KEY (person_id) references persons (id),
  constraint chk_balance_non_negative check ((balance >= 0))
) TABLESPACE pg_default;

create table public.plans (
  id bigint generated by default as identity not null,
  name text not null,
  description text not null,
  feature_mask bigint not null default 0,
  price bigint not null default 0,
  created_at timestamp without time zone not null default now(),
  constraint plans_pkey primary key (id),
  constraint chk_price_positive check ((price >= 0)),
  constraint chk_feature_mask_positive check ((feature_mask >= 0))
) TABLESPACE pg_default;

create table public.subscriptions (
  id bigint generated by default as identity not null,
  plan_id bigint not null,
  seller_id bigint not null,
  person_id bigint not null,
  status text not null,
  created_at timestamp without time zone not null default now(),
  constraint subscriptions_pkey primary key (id),
  constraint subscriptions_plan_id_fkey foreign KEY (plan_id) references plans (id),
  constraint subscriptions_seller_id_fkey foreign KEY (seller_id) references persons (id),
  constraint subscriptions_person_id_fkey foreign KEY (person_id) references persons (id),
  constraint chk_subscription_status check (
    (
      status = any (
        array['active'::text, 'expired'::text, 'canceled'::text]
      )
    )
  )
) TABLESPACE pg_default;

create table public.games (
  id bigint generated by default as identity not null,
  name text not null,
  slug text not null,
  description text not null,
  image_url text not null,
  download_url text not null,
  created_at timestamp without time zone not null default now(),
  constraint games_pkey primary key (id)
) TABLESPACE pg_default;

--====================
--===== FUNCTION =====
--====================
create or replace function is_admin () returns boolean as $$
declare
  current_telegram_id bigint;
begin
  current_telegram_id := (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint;
  return exists (
    select 1 from persons p
    join person_roles r on r.person_id = p.id
    where p.telegram_id = current_telegram_id and r.role = 'admin'
  );
end;
$$ language plpgsql stable;

create or replace function fun_generate_unique_otp (person_id_input bigint, otp_length int default 6) returns text language plpgsql as $$
declare
  var_generated_otp text;
  var_try_count int := 0;
  var_is_otp_exists boolean;
  var_recent_otp_count int := 0;
begin

  select count(*) into var_recent_otp_count
  from otps
  where person_id = person_id_input
    and created_at > now() - interval '5 minutes';

  if var_recent_otp_count >= 3 then
    raise exception 'You must wait before generating another OTP.';
  end if;
  
  loop
    var_generated_otp := (
      select string_agg(
        substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', trunc(random() * 36)::int + 1, 1),
        ''
      )
      from generate_series(1, otp_length)
    );
    
    select exists (
      select 1 from otps
      where otp = var_generated_otp
        and expires_at > now()
    ) into var_is_otp_exists;

    exit when not var_is_otp_exists;

    var_try_count := var_try_count + 1;
    if var_try_count > 10 then
      raise exception 'Failed to generate unique OTP after 10 tries';
    end if;
  end loop;

  insert into otps (person_id, otp)
  values (person_id_input, var_generated_otp);

  return var_generated_otp;
end;
$$;

create or replace function fun_verify_otp (
  otp_input text,
  ip_input text,
  region_input text,
  device_hash_input text
) returns table (person_id bigint, token text) language plpgsql security definer as $$
declare
  var_person_id bigint;
  var_telegram_id bigint;
  var_otp_expires_at timestamp;
  var_is_existing_device boolean;
  var_device_count int;
begin

  select
    p.id,
    p.telegram_id,
    o.expires_at
  into
    var_person_id,
    var_telegram_id,
    var_otp_expires_at
  from otps o
  join persons p on o.person_id = p.id
  where o.otp = otp_input
    and o.expires_at > now()
  order by o.created_at desc
  limit 1;

  if var_person_id is null then
    raise exception 'The verification code is invalid or has expired.';
  end if;

  select count(*) into var_device_count
  from (
    select distinct ip, region, device_hash
    from ipinfos
    where person_id = var_person_id
  ) as location_set;

  select exists (
    select 1
    from ipinfos
    where person_id = var_person_id
      and ip = ip_input
      and region = region_input
      and device_hash = device_hash_input
  ) into var_is_existing_device;

  if var_device_count >= 2 and not var_is_existing_device then
    raise exception 'Login denied: Account already active from 2 different locations.';
  end if;

  return query
  select
    var_person_id as person_id,
    extensions.sign(
      json_build_object(
        'sub', var_person_id::text,
        'telegram_id', var_telegram_id::text,
        'device_hash', device_hash_input::text,
        'role', 'authenticated',
        'exp', extract(epoch from now() + interval '14 day')::int
      ),
      'ebb56de2c4b4eb4d14b81f5d66eb50c3555d84a47127e8511cb024888e162969',
      'HS256'
    ) as token;
end;
$$;

--====================
--===== TRIGGER ======
--====================


-- ================================
-- RLS Policies for Supabase Schema
-- ================================
create policy select_games on public.games
for select
using (
  exists (
    select 1 from persons p
    where p.id::text = current_setting('request.jwt.claims', true)::json ->> 'sub'
  )
);


create policy select_persons on persons for
select
  using (
    telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    or is_admin ()
  );

create policy update_persons on persons
for update
  using (
    telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    or is_admin ()
  );


create policy select_person_logs on person_logs for
select
  using (
    telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    or is_admin ()
  );

create policy update_person_logs on person_logs
for update
  using (
    telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    or is_admin ()
  );

create policy select_person_roles on person_roles for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = person_roles.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy select_wallets on wallets for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = wallets.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy select_otps on otps for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = otps.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy insert_otps on otps for INSERT
with
  check (
    exists (
      select
        1
      from
        persons p
      where
        p.id = otps.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy select_ipinfos on ipinfos for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = ipinfos.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy insert_ipinfos on ipinfos for INSERT
with
  check (
    exists (
      select
        1
      from
        persons p
      where
        p.id = ipinfos.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );

create policy select_plans on plans for
select
  using (true);

create policy select_subscriptions on subscriptions for
select
  using (
    exists (
      select
        1
      from
        persons p
      where
        p.id = subscriptions.person_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or exists (
      select
        1
      from
        persons p
      where
        p.id = subscriptions.seller_id
        and p.telegram_id::text = current_setting('request.jwt.claims', true)::json ->> 'telegram_id'
    )
    or is_admin ()
  );
  
--Enabled extensions
--plpgsql
--1.0

--uuid-ossp
--1.1

--pg_stat_statements
--1.10

--pg_net
--0.14.0

--pg_graphql
--1.5.11

--pgjwt
--0.2.0

--pgcrypto
--1.3